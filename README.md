# DiffDrivePWM-ROS2-MotorController
A ROS2 package to drive 2 DC motors with PWM generated by Raspberry PI 4

## Prepare the Raspberry PI 4

### Install Ubuntu 22.04

ROS2 Humble requires Ubuntu 22.04

On your development computer, use Raspberry imager to create an SD card with 

![](docs/ubuntu.png)

### Install ROS2 Humble on the Raspberry PI 4

* Follow these instructions: https://docs.ros.org/en/humble/Installation/Ubuntu-Install-Debs.html
* When you arrive at "Install ROS 2 packages" install only:
`sudo apt install ros-humble-ros-base` and stop there.
* Source setup: to use ROS2 you need to source it and the best option is to add `source /opt/ros/humble/setup.bash` at the end of your .bashrc

## Create the ROS2 

### Overview 
This package, written in C++:
* controls two DC motors using PWM
* PWM is generated by the Raspberry Pi 4 itself, with pigpio,
* the electronics is a simple "H bridge" based on DRV8833 IC.
* subscribes to the RSO2 topic /cmd_vel
* has two optional parameters:
  * wheels_distance
  * max_speed

Steps to Create the ROS2 Package
1. Install pigpio
Make sure pigpio is installed and running on your system:

bash
Copia codice
sudo apt-get update
sudo apt-get install pigpio
sudo systemctl start pigpiod
sudo systemctl enable pigpiod
2. Create the ROS2 Package
Navigate to your ROS2 workspace and create a new C++ package:

bash
Copia codice
cd ~/ros2_ws/src
ros2 pkg create motor_controller --build-type ament_cmake --dependencies rclcpp geometry_msgs
This creates a folder motor_controller/ with the basic structure for the package.

3. Add the Source Code
Now, let's add the necessary files to the package.

a. Create the Header File
Create a header file to define the MotorController class:

File: include/motor_controller/motor_controller_node.hpp

cpp
Copia codice
#ifndef MOTOR_CONTROLLER_NODE_HPP_
#define MOTOR_CONTROLLER_NODE_HPP_

#include "rclcpp/rclcpp.hpp"
#include "geometry_msgs/msg/twist.hpp"
#include <pigpio.h>

class MotorController : public rclcpp::Node
{
public:
    MotorController();
    ~MotorController();

private:
    void cmd_vel_callback(const geometry_msgs::msg::Twist::SharedPtr msg);
    void set_motor_speed(float left, float right);
    void stop_motors();

    rclcpp::Subscription<geometry_msgs::msg::Twist>::SharedPtr subscription_;

    // GPIO pins for the motors
    int motor1_pwm_pin_;
    int motor1_dir_pin_;
    int motor2_pwm_pin_;
    int motor2_dir_pin_;

    // Parameters
    double wheels_distance_;
    double max_speed_;
};

#endif  // MOTOR_CONTROLLER_NODE_HPP_
b. Create the Source File
Now, create the source file that implements the motor controller node.

File: src/motor_controller_node.cpp

cpp
Copia codice
#include "motor_controller/motor_controller_node.hpp"

MotorController::MotorController() : Node("motor_controller_node")
{
    // Declare parameters with default values
    this->declare_parameter<double>("wheels_distance", 0.2); // Example: 20 cm
    this->declare_parameter<double>("max_speed", 1.0); // Example: 1 m/s

    // Get parameter values
    this->get_parameter("wheels_distance", wheels_distance_);
    this->get_parameter("max_speed", max_speed_);

    // Initialize pigpio
    if (gpioInitialise() < 0) {
        RCLCPP_ERROR(this->get_logger(), "Failed to initialize pigpio!");
        throw std::runtime_error("Failed to initialize pigpio");
    }

    // Define the GPIO pins (adjust these to match your wiring)
    motor1_pwm_pin_ = 17;  // GPIO17 (Pin 11)
    motor1_dir_pin_ = 27;  // GPIO27 (Pin 13)
    motor2_pwm_pin_ = 22;  // GPIO22 (Pin 15)
    motor2_dir_pin_ = 23;  // GPIO23 (Pin 16)

    // Set GPIO modes
    gpioSetMode(motor1_pwm_pin_, PI_OUTPUT);
    gpioSetMode(motor1_dir_pin_, PI_OUTPUT);
    gpioSetMode(motor2_pwm_pin_, PI_OUTPUT);
    gpioSetMode(motor2_dir_pin_, PI_OUTPUT);

    // Stop motors initially
    stop_motors();

    // Subscribe to the /cmd_vel topic
    subscription_ = this->create_subscription<geometry_msgs::msg::Twist>(
        "/cmd_vel", 10, std::bind(&MotorController::cmd_vel_callback, this, std::placeholders::_1));

    RCLCPP_INFO(this->get_logger(), "Motor Controller Node has been started.");
}

MotorController::~MotorController()
{
    stop_motors();
    gpioTerminate();
}

void MotorController::cmd_vel_callback(const geometry_msgs::msg::Twist::SharedPtr msg)
{
    // Extract linear and angular velocity
    float linear_x = msg->linear.x;
    float angular_z = msg->angular.z;

    // Clamp linear velocity to the max speed
    linear_x = std::max(std::min(linear_x, max_speed_), -max_speed_);

    // Calculate individual motor speeds for differential drive
    float left_speed = linear_x + (angular_z * wheels_distance_ / 2.0);
    float right_speed = linear_x - (angular_z * wheels_distance_ / 2.0);

    // Clamp speeds to [-max_speed, max_speed]
    left_speed = std::max(std::min(left_speed, max_speed_), -max_speed_);
    right_speed = std::max(std::min(right_speed, max_speed_), -max_speed_);

    // Set motor speeds
    set_motor_speed(left_speed, right_speed);
}

void MotorController::set_motor_speed(float left, float right)
{
    // Convert [-max_speed, max_speed] speed to PWM duty cycle [0, 255]
    int left_pwm = static_cast<int>(std::abs(left) / max_speed_ * 255);
    int right_pwm = static_cast<int>(std::abs(right) / max_speed_ * 255);

    // Set direction and apply PWM for the left motor
    if (left >= 0) {
        gpioWrite(motor1_dir_pin_, 1);  // Forward direction
        gpioPWM(motor1_pwm_pin_, left_pwm);
    } else {
        gpioWrite(motor1_dir_pin_, 0);  // Reverse direction
        gpioPWM(motor1_pwm_pin_, 255 - left_pwm);  // Complement the duty cycle
    }

    // Set direction and apply PWM for the right motor
    if (right >= 0) {
        gpioWrite(motor2_dir_pin_, 1);  // Forward direction
        gpioPWM(motor2_pwm_pin_, right_pwm);
    } else {
        gpioWrite(motor2_dir_pin_, 0);  // Reverse direction
        gpioPWM(motor2_pwm_pin_, 255 - right_pwm);  // Complement the duty cycle
    }

    RCLCPP_INFO(this->get_logger(), "Set left PWM: %d, right PWM: %d", left_pwm, right_pwm);
}

void MotorController::stop_motors()
{
    gpioPWM(motor1_pwm_pin_, 0);
    gpioPWM(motor2_pwm_pin_, 0);
    RCLCPP_INFO(this->get_logger(), "Motors stopped.");
}

int main(int argc, char *argv[])
{
    rclcpp::init(argc, argv);
    auto node = std::make_shared<MotorController>();
    rclcpp::spin(node);
    rclcpp::shutdown();
    return 0;
}
4. Update CMakeLists.txt
Modify the CMakeLists.txt file to ensure it correctly builds the C++ node.

File: CMakeLists.txt

cmake
Copia codice
cmake_minimum_required(VERSION 3.5)
project(motor_controller)

# Find dependencies
find_package(ament_cmake REQUIRED)
find_package(rclcpp REQUIRED)
find_package(geometry_msgs REQUIRED)

# Include directories
include_directories(include)

# Build the motor controller node
add_executable(motor_controller_node src/motor_controller_node.cpp)

ament_target_dependencies(motor_controller_node rclcpp geometry_msgs)

install(TARGETS motor_controller_node
  DESTINATION lib/${PROJECT_NAME})

ament_package()
5. Update package.xml
Ensure the package.xml file includes the necessary dependencies:

File: package.xml

xml
Copia codice
<package format="2">
  <name>motor_controller</name>
  <version>0.0.0</version>
  <description>ROS2 C++ package to control two DC motors using pigpio</description>

  <maintainer email="your_email@example.com">Your Name</maintainer>
  <license>Apache 2.0</license>

  <buildtool_depend>ament_cmake</buildtool_depend>
  <depend>rclcpp</depend>
  <depend>geometry_msgs</depend>
  <exec_depend>pigpio</exec_depend>

  <build_depend>pigpio</build_depend>

  <export>
    <build_type>ament_cmake</build_type>
  </export>
</package>
6. Build the Package
Now, go back to the workspace and build the package:

bash
Copia codice
cd ~/ros2_ws
colcon build --packages-select motor_controller
Source the workspace:

bash
Copia codice
source install/setup.bash
7. Running the Node
To run the node, use:

bash
Copia codice
ros2 run motor_controller motor_controller_node
You can publish messages to the /cmd_vel topic to test the motor control:

bash
Copia codice
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 0.5}, angular: {z: 0.1}}"
This will send velocity commands to the motors. Adjust the linear.x and angular.z fields as needed.

Conclusion
This set of instructions should help you create the ROS2 package in C++ to control DC motors using PWM and pigpio, with parameters like wheels_distance and max_speed. Let me know if you need further help!
